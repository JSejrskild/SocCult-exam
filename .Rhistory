# Ensure the municipality names are in lowercase
df1$municipalities <- tolower(df1$municipalities)
df2$municipalities <- tolower(df2$municipalities)
# Get unique municipalities from each dataset
municipalities_df1 <- unique(df1$municipalities)
municipalities_df2 <- unique(df2$municipalities)
# Find municipalities that are in df1 but not in df2
missing_in_df2 <- setdiff(municipalities_df1, municipalities_df2)
# Find municipalities that are in df2 but not in df1
missing_in_df1 <- setdiff(municipalities_df2, municipalities_df1)
# Print the results
cat("Municipalities in df1 but not in df2:\n")
print(missing_in_df2)
cat("Municipalities in df2 but not in df1:\n")
print(missing_in_df1)
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(dplyr)
Population <- read.csv("Population1.csv")
Fertility <- read.csv("Fertility.csv")
Fertilitetsrater_komune_alder <- read_csv("Fertilitetsrater_land_alder.csv")
municipalities_economy <- read_csv("municipalities_economy.csv")
#Fjern mellemrum
Fertilitetsrater_komune_alder <- Fertilitetsrater_komune_alder %>%
rename(Samlet_fertilitet = `Samlet fertilitet`)
#kolonne municipalities
Fertilitetsrater_komune_alder <- Fertilitetsrater_komune_alder %>%
rename(municipalities = ...1)
Fertilitetsrater_komune_alder$fertilitetsrate <- round((Fertilitetsrater_komune_alder$Samlet_fertilitet / 1000), 1)
#Make all Municipalitites lowercase
Fertilitetsrater_komune_alder$municipalities <- tolower(Fertilitetsrater_komune_alder$municipalities)
municipalities_economy <- municipalities_economy %>%
rename(municipalities = City)
#Make all Municipalitites lowercase
municipalities_economy$municipalities <- tolower(municipalities_economy$municipalities)
quantile(municipalities_economy$Price, probs = , na.rm = FALSE)
#  0%     25%     50%     75%    100%
#1276600 1575325 1804400 2099425 7413700
#Make a score of economy
thresholds <- c(-Inf, 1575325,2099425 , Inf)
scores <- c(1, 2, 3)
# Create a new column to store the scores
municipalities_economy$econ_score <- cut(municipalities_economy$Price, breaks = thresholds, labels = scores)
municipalities_economy$econ_score <- as.numeric(municipalities_economy$econ_score)
# Inspect
score_counts <- table(municipalities_economy$econ_score)
# Plot pie chart
pie(score_counts,
main = "Pie Chart of Econ Scores",
col = rainbow(length(score_counts)),
labels = paste(names(score_counts), ": ", score_counts))
# Add a legend
legend("topright",
legend = names(score_counts),
fill = rainbow(length(score_counts)),
title = "Econ Scores")
#Scatterplot
municipality_indices <- seq_along(fertility$municipalities)
plot(municipality_indices,
fertility$fertilitetsrate,
xlab = "Municipalities",
ylab = "fertility",
main = "Scatterplot of Fertility Rate by Economic Group",
col = fertility$econ_score)
Population <- Population %>%
rename(municipalities = X)
Population$municipalities <- tolower(Population$municipalities)
fertility <- merge(Fertilitetsrater_komune_alder, municipalities_economy, by = "municipalities", all = FALSE)
fertility2 <- merge(fertility, Population, by = "municipalities", all = FALSE)
# subset
fertility2 <- fertility2[, c("municipalities", "fertilitetsrate", "econ_score", "Percent")]
write.csv(fertility2, "Fertility_clean.csv")
# Load your datasets
df1 <- Fertilitetsrater_komune_alder
df2 <- municipalities_economy
# Ensure the municipality names are in lowercase
df1$municipalities <- tolower(df1$municipalities)
df2$municipalities <- tolower(df2$municipalities)
# Get unique municipalities from each dataset
municipalities_df1 <- unique(df1$municipalities)
municipalities_df2 <- unique(df2$municipalities)
# Find municipalities that are in df1 but not in df2
missing_in_df2 <- setdiff(municipalities_df1, municipalities_df2)
# Find municipalities that are in df2 but not in df1
missing_in_df1 <- setdiff(municipalities_df2, municipalities_df1)
# Print the results
cat("Municipalities in df1 but not in df2:\n")
print(missing_in_df2)
cat("Municipalities in df2 but not in df1:\n")
print(missing_in_df1)
# Load your datasets
df1 <- fertility
df2 <- Population
# Ensure the municipality names are in lowercase
df1$municipalities <- tolower(df1$municipalities)
df2$municipalities <- tolower(df2$municipalities)
# Get unique municipalities from each dataset
municipalities_df1 <- unique(df1$municipalities)
municipalities_df2 <- unique(df2$municipalities)
# Find municipalities that are in df1 but not in df2
missing_in_df2 <- setdiff(municipalities_df1, municipalities_df2)
# Find municipalities that are in df2 but not in df1
missing_in_df1 <- setdiff(municipalities_df2, municipalities_df1)
# Print the results
cat("Municipalities in df1 but not in df2:\n")
print(missing_in_df2)
cat("Municipalities in df2 but not in df1:\n")
print(missing_in_df1)
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(dplyr)
Population <- read.csv("Population1.csv")
Fertility <- read.csv("Fertility.csv")
Fertilitetsrater_komune_alder <- read_csv("Fertilitetsrater_land_alder.csv")
municipalities_economy <- read_csv("municipalities_economy.csv")
#Fjern mellemrum
Fertilitetsrater_komune_alder <- Fertilitetsrater_komune_alder %>%
rename(Samlet_fertilitet = `Samlet fertilitet`)
#kolonne municipalities
Fertilitetsrater_komune_alder <- Fertilitetsrater_komune_alder %>%
rename(municipalities = ...1)
Fertilitetsrater_komune_alder$fertilitetsrate <- round((Fertilitetsrater_komune_alder$Samlet_fertilitet / 1000), 1)
#Make all Municipalitites lowercase
Fertilitetsrater_komune_alder$municipalities <- tolower(Fertilitetsrater_komune_alder$municipalities)
municipalities_economy <- municipalities_economy %>%
rename(municipalities = City)
#Make all Municipalitites lowercase
municipalities_economy$municipalities <- tolower(municipalities_economy$municipalities)
quantile(municipalities_economy$Price, probs = , na.rm = FALSE)
#  0%     25%     50%     75%    100%
#1276600 1575325 1804400 2099425 7413700
#Make a score of economy
thresholds <- c(-Inf, 1575325,2099425 , Inf)
scores <- c(1, 2, 3)
# Create a new column to store the scores
municipalities_economy$econ_score <- cut(municipalities_economy$Price, breaks = thresholds, labels = scores)
municipalities_economy$econ_score <- as.numeric(municipalities_economy$econ_score)
# Inspect
score_counts <- table(municipalities_economy$econ_score)
# Plot pie chart
pie(score_counts,
main = "Pie Chart of Econ Scores",
col = rainbow(length(score_counts)),
labels = paste(names(score_counts), ": ", score_counts))
# Add a legend
legend("topright",
legend = names(score_counts),
fill = rainbow(length(score_counts)),
title = "Econ Scores")
#Scatterplot
municipality_indices <- seq_along(fertility$municipalities)
plot(municipality_indices,
fertility$fertilitetsrate,
xlab = "Municipalities",
ylab = "fertility",
main = "Scatterplot of Fertility Rate by Economic Group",
col = fertility$econ_score)
Population <- Population %>%
rename(municipalities = X)
Population$municipalities <- tolower(Population$municipalities)
fertility <- merge(Fertilitetsrater_komune_alder, municipalities_economy, by = "municipalities", all = FALSE)
fertility2 <- merge(fertility, Population, by = "municipalities", all = FALSE)
# subset
fertility2 <- fertility2[, c("municipalities", "fertilitetsrate", "econ_score", "Percent")]
write.csv(fertility2, "Fertility_clean.csv")
# Load your datasets
df1 <- fertility
df2 <- Population
# Ensure the municipality names are in lowercase
df1$municipalities <- tolower(df1$municipalities)
df2$municipalities <- tolower(df2$municipalities)
# Get unique municipalities from each dataset
municipalities_df1 <- unique(df1$municipalities)
municipalities_df2 <- unique(df2$municipalities)
# Find municipalities that are in df1 but not in df2
missing_in_df2 <- setdiff(municipalities_df1, municipalities_df2)
# Find municipalities that are in df2 but not in df1
missing_in_df1 <- setdiff(municipalities_df2, municipalities_df1)
# Print the results
cat("Municipalities in df1 but not in df2:\n")
print(missing_in_df2)
cat("Municipalities in df2 but not in df1:\n")
print(missing_in_df1)
sum(fertility2$Percent)
setwd("~/Documents/GitHub/SocCult-exam")
knitr::opts_chunk$set(echo = TRUE)
# Load packages
library(brms)
library(tidyverse)
library(ggplot2)
library(rethinking)
read.csv("data_w_cashbenefit_2205.csv")
cashbenefit <- read.csv("data_w_cashbenefit_2205.csv")
cashbonus <- read.csv("data_w_cashbonus_2205.csv")
baseline <- read.csv("data_wo_bonus_2205.csv")
#Make a column with condition
cashbenefit$condition <- 2
cashbonus$conditon <- 1
baseline$condition <- 0
#Merge the data frames so we can use it to model
#Merge the data frames so we can use it to model
df_combined <- rbind(cashbenefit, cashbonus, baseline)
#Merge the data frames so we can use it to model
df_combined <- rbind("cashbenefit", "cashbonus", "baseline")
#Merge the data frames so we can use it to model
df_combined <- rbind(cashbenefit, cashbonus, baseline)
View(baseline)
View(cashbenefit)
View(cashbonus)
cashbenefit <- read.csv("long_cashbenefit_2205.csv")
cashbonus <- read.csv("long_cashbonus_2205.csv")
baseline <- read.csv("long_bonus_2205.csv")
cashbenefit <- read.csv("long_cashbenefit_2205.csv")
cashbonus <- read.csv("long_cashbonus_2205.csv")
baseline <- read.csv("long_baseline_2205.csv")
#Make a column with condition
cashbenefit$condition <- 2
cashbonus$conditon <- 1
baseline$condition <- 0
#Merge the data frames so we can use it to model
df_combined <- rbind(cashbenefit, cashbonus, baseline)
# Display column names for each data frame
colnames(cashbenefit)
colnames(cashbonus)
colnames(baseline)
# Clean column names for each data frame
clean_colnames <- function(df) {
colnames(df) <- make.names(trimws(tolower(colnames(df))))
return(df)
}
cashbenefit <- clean_colnames(cashbenefit)
cashbonus <- clean_colnames(cashbonus)
baseline <- clean_colnames(baseline)
#Merge the data frames so we can use it to model
df_combined <- rbind(cashbenefit, cashbonus, baseline)
# Verify that column names match
identical(colnames(cashbenefit), colnames(cashbonus)) && identical(colnames(cashbenefit), colnames(baseline))
colnames(cashbenefit)
colnames(cashbonus)
colnames(baseline)
str(colnames(cashbenefit))
str(colnames(cashbonus))
str(colnames(baseline))
#Make a column with condition
cashbenefit$condition <- 2
cashbonus$condition <- 1
baseline$condition <- 0
#Merge the data frames so we can use it to model
df_combined <- rbind(cashbenefit, cashbonus, baseline)
#Make a column with condition
cashbenefit$condition <- 2
cashbonus$condition <- 1
baseline$condition <- 0
#Merge the data frames so we can use it to model
df_combined <- rbind(cashbenefit, cashbonus, baseline)
# Display column names for each data frame
colnames(cashbenefit)
colnames(cashbonus)
colnames(baseline)
# Clean column names for each data frame
clean_colnames <- function(df) {
colnames(df) <- make.names(trimws(tolower(colnames(df))))
return(df)
}
cashbenefit <- clean_colnames(cashbenefit)
cashbonus <- clean_colnames(cashbonus)
baseline <- clean_colnames(baseline)
# Verify that column names match
identical(colnames(cashbenefit), colnames(cashbonus)) && identical(colnames(cashbenefit), colnames(baseline))
str(colnames(cashbenefit))
str(colnames(cashbonus))
str(colnames(baseline))
cashbenefit <- read.csv("long_cashbenefit_2205.csv")
cashbonus <- read.csv("long_cashbonus_2205.csv")
baseline <- read.csv("long_baseline_2205.csv")
#Make a column with condition
cashbenefit$condition <- 2
cashbonus$condition <- 1
baseline$condition <- 0
#Merge the data frames so we can use it to model
df_combined <- rbind(cashbenefit, cashbonus, baseline)
# Specify a Poisson model for count data
model_formula <- bf(Children ~ condition)
# Fit the model
fit <- brm(model_formula, data = df_combined, family = poisson(), chains = 4, iter = 2000)
# Summary of the model
summary(fit)
# Obtain the posterior samples
posterior_samples <- posterior_samples(fit)
# Compare the posterior distributions for the conditions
posterior_summary <- posterior_samples %>%
group_by(condition) %>%
summarize(
mean = mean(Children),
median = median(Children),
lower = quantile(Children, 0.025),
upper = quantile(Children, 0.975)
)
str(posterior_samples)
# Compare the posterior distributions for the conditions
posterior_summary <- posterior_samples %>%
group_by(b_condition) %>%
summarize(
mean = mean(Children),
median = median(Children),
lower = quantile(Children, 0.025),
upper = quantile(Children, 0.975)
)
# Obtain the posterior samples
posterior_samples <- posterior_samples(fit)
# Compare the posterior distributions for the conditions
posterior_summary <- posterior_samples %>%
group_by(b_condition) %>%
summarize(
mean = mean(b_Intercept),
median = median(b_Intercept),
lower = quantile(b_Intercept, 0.025),
upper = quantile(b_Intercept, 0.975)
)
print(posterior_summary)
View(cashbonus)
print(colnames(cashbonus))
real_data <- read.csv("fertility_clean.csv")
View(real_data)
library(readr)
Fertilitetsrater_land_alder <- read_csv("~/Desktop/Lyfe/Uni/SocCult/Fertilitetsrater_land_alder.csv")
View(Fertilitetsrater_land_alder)
real_data <- read.csv("~/Desktop/Lyfe/Uni/SocCult/Population1.csv")
View(real_data)
# Rename age columns in real data
real_data <- real_data %>%
rename(
"1519" = `X15.19.aar`,
"2024" = `X20.24.aar`,
"2529" = `X25.29.aar`,
"3034" = `X30.34.aar`,
"3539" = `X35.39.aar`,
"4044" = `X40.44.aar`,
"4549" = `X45.49.aar`)
#Validation of our data
# Make the values to percentages
age_group_columns = ['1519', '2024', '2529', '3034', '3539', '4044', '4549']
# Make the values to percentages
age_group_columns = c['1519', '2024', '2529', '3034', '3539', '4044', '4549']
# Make the values to percentages
age_group_columns = c('1519', '2024', '2529', '3034', '3539', '4044', '4549')
for col in age_group_columns:
# Transform the values to reflect their percentage of the 'Antal' for each row
for (col in age_group_columns) {
data[[col]] <- (data[[col]] / data$Antal) * 100
}
# Make the values to percentages
age_group_columns = c('1519', '2024', '2529', '3034', '3539', '4044', '4549')
# Transform the values to reflect their percentage of the 'Antal' for each row
for (col in age_group_columns) {
data[[col]] <- (data[[col]] / data$Antal) * 100
}
# Make the values to percentages
age_group_columns <- c('1519', '2024', '2529', '3034', '3539', '4044', '4549')
# Transform the values to reflect their percentage of the 'Antal' for each row
for (col in age_group_columns) {
data[[col]] <- (data[[col]] / data$Antal) * 100
}
for (col in age_group_columns) {
real_data[[col]] <- (real_data[[col]] / real_data$Antal) * 100
}
# Print the transformed data
print(data)
# Print the transformed data
print(real_data)
real_data <- read.csv("~/Desktop/Lyfe/Uni/SocCult/Population1.csv")
# Rename age columns in real data
real_data <- real_data %>%
rename(
"1519" = `X15.19.aar`,
"2024" = `X20.24.aar`,
"2529" = `X25.29.aar`,
"3034" = `X30.34.aar`,
"3539" = `X35.39.aar`,
"4044" = `X40.44.aar`,
"4549" = `X45.49.aar`)
# Make the values to percentages
age_group_columns <- c('1519', '2024', '2529', '3034', '3539', '4044', '4549')
# Transform the values to reflect their percentage of the 'Antal' for each row
for (col in age_group_columns) {
real_data[[col]] <- (real_data[[col]] / real_data$Antal) * 100
}
#Validation of our data
# Iterate through each unique Municipality
unique_municipalities <- unique(baseline$Municipality)
for (municipality in unique_municipalities) {
cat("Counts for Municipality", municipality, ":\n")
# Filter data for the current municipality
filtered_data <- baseline %>%
filter(Municipality == municipality)
# Count occurrences of each Age_group
counts <- filtered_data %>%
count(Age_groups)
# Print the counts
print(counts)
cat("\n")
unique_municipalities <- unique(data$Municipality)
for (municipality in unique_municipalities) {
cat("Counts for Municipality", municipality, ":\n")
# Filter data for the current municipality
filtered_data <- data %>%
filter(Municipality == municipality)
# Count occurrences of each Age_group
counts <- filtered_data %>%
count(Age_groups)
# Create a new row for the counts data frame
new_row <- c(municipality, 0, 0, 0, 0,0,0,0) # Initialize with 0 counts for each age group
for (i in 1:nrow(counts)) {
age_group <- counts[i, "Age_groups"]
count <- counts[i, "n"]
new_row[age_group + 1] <- count # +1 to match column index
}
# Append the new row to count_data
count_data <- rbind(count_data, as.data.frame(t(new_row)))
}
# Rename columns
colnames(count_data) <- c("Municipality", '1519', '2024', '2529', '3034', '3539', '4044', '4549')
# Print the resulting data frame
print(count_data)
}
unique_municipalities <- unique(data$Municipality)
unique_municipalities <- unique(baseline$Municipality)
unique_municipalities <- unique(baseline$Municipality)
for (municipality in unique_municipalities) {
cat("Counts for Municipality", municipality, ":\n")
# Filter data for the current municipality
filtered_data <- baseline %>%
filter(Municipality == Municipality)
# Count occurrences of each Age_group
counts <- filtered_data %>%
count(Age_groups)
# Create a new row for the counts data frame
new_row <- c(Municipality, 0, 0, 0, 0,0,0,0) # Initialize with 0 counts for each age group
for (i in 1:nrow(counts)) {
age_group <- counts[i, "Age_Group"]
count <- counts[i, "n"]
new_row[age_group + 1] <- count # +1 to match column index
}
# Append the new row to count_data
count_data <- rbind(count_data, as.data.frame(t(new_row)))
}
unique_municipalities <- unique(baseline$Municipality)
for (municipality in unique_municipalities) {
cat("Counts for Municipality", municipality, ":\n")
# Filter data for the current municipality
filtered_data <- baseline %>%
filter(Municipality == Municipality)
# Count occurrences of each Age_group
counts <- filtered_data %>%
count(Age_Group)
# Create a new row for the counts data frame
new_row <- c(Municipality, 0, 0, 0, 0,0,0,0) # Initialize with 0 counts for each age group
for (i in 1:nrow(counts)) {
age_group <- counts[i, "Age_Group"]
count <- counts[i, "n"]
new_row[age_group + 1] <- count # +1 to match column index
}
# Append the new row to count_data
count_data <- rbind(count_data, as.data.frame(t(new_row)))
}
unique_municipalities <- unique(baseline$Municipality)
for (municipality in unique_municipalities) {
cat("Counts for Municipality", municipality, ":\n")
# Filter data for the current municipality
filtered_data <- baseline %>%
filter(Municipality == Municipality)
# Count occurrences of each Age_group
counts <- filtered_data %>%
count(Age_Group)
# Create a new row for the counts data frame
new_row <- c( 0, 0, 0, 0,0,0,0) # Initialize with 0 counts for each age group
for (i in 1:nrow(counts)) {
age_group <- counts[i, "Age_Group"]
count <- counts[i, "n"]
new_row[age_group + 1] <- count # +1 to match column index
}
# Append the new row to count_data
count_data <- rbind(count_data, as.data.frame(t(new_row)))
}
unique_municipalities <- unique(baseline$Municipality)
for (municipality in unique_municipalities) {
cat("Counts for Municipality", municipality, ":\n")
# Filter data for the current municipality
filtered_data <- baseline %>%
filter(Municipality == Municipality)
# Count occurrences of each Age_group
counts <- filtered_data %>%
count(Age_Group)
# Create a new row for the counts data frame
new_row <- c( 0, 0, 0, 0,0,0,0) # Initialize with 0 counts for each age group
for (i in 1:nrow(counts)) {
age_group <- counts[i, "Age_Group"]
count <- counts[i, "n"]
new_row[age_group + 1] <- count # +1 to match column index
}
# Append the new row to count_data
count_data <- as.data.frame(t(new_row))
}
# Rename columns
colnames(count_data) <- c("Municipality", '1519', '2024', '2529', '3034', '3539', '4044', '4549')
# Print the resulting data frame
print(count_data)
}
View(count_data)
baseline <- read.csv("data_wo_bonus_2205.csv")
View(baseline)
View(baseline)
